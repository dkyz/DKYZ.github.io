<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Delin Zhang' Page</title><meta name="author" content="Delin Zhang"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><header id="page_header"><div class="header_wrap"><div id="blog_name"><a class="blog_title" id="site-name" href="/">Delin Zhang' Page</a></div><button class="menus_icon"><div class="navicon"></div></button><ul class="menus_items"><li class="menus_item"><a class="site-page" href="/#Publications"> Publications</a></li><li class="menus_item"><a class="site-page" href="/"> About</a></li><li class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://phower.me"> Blog</a></li></ul></div></header><main id="page_main"><div class="side-card sticky"><div class="card-wrap" itemscope itemtype="http://schema.org/Person"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/profile.jpg'" alt="avatar"></div><div class="author-discrip"><h3>Delin Zhang</h3><p class="author-bio">Your biography can be writed down here.</p></div><div class="author-links"><button class="btn m-social-links">Links</button><ul class="social-icons"><li><a class="social-icon" href="https://github.com/dkyz" target="_blank"><i class="fab fa-github" aria-hidden="true"></i></a></li><li><a class="social-icon" href="dkyz.cuhksz@gmail.com" target="_blank"><i class="fas fa-envelope" aria-hidden="true"></i></a></li></ul><ul class="social-links"><li><a class="e-social-link" href="/" target="_blank"><i class="fas fa-graduation-cap" aria-hidden="true"></i><span>Google Scholar</span></a></li><li><a class="e-social-link" href="/" target="_blank"><i class="fab fa-orcid" aria-hidden="true"></i><span>ORCID</span></a></li></ul></div><a class="cv-links" href="/attaches/CV.pdf" target="_blank"><i class="fas fa-file-pdf" aria-hidden="true"><span>My Detail CV.</span></i></a></div></div><div class="page" itemscope itemtype="http://schema.org/CreativeWork"><h2 class="page-title">“数学建模-TOPSIS-(优劣解距离法)-学习笔记”</h2><article><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ul>
<li><a href="#topsis">TOPSIS</a><ul>
<li><a href="#topsis%E5%8E%9F%E7%90%86">TOPSIS原理</a><ul>
<li><a href="#%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E5%B1%80%E9%99%90">层次分析法的局限</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BAtopsis%E5%88%86%E6%9E%90%E6%B3%95">问题引出TOPSIS分析法</a><ul>
<li><a href="#%E9%97%AE%E9%A2%98%E6%8B%93%E5%B1%95">问题拓展</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#topsis%E6%AD%A5%E9%AA%A4">TOPSIS步骤</a><ul>
<li><a href="#%E5%B0%86%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%9F%A9%E9%98%B5%E6%AD%A3%E5%90%91%E5%8C%96">将原始数据矩阵正向化</a><ul>
<li><a href="#%E5%B0%86%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%9E%8B%E6%8C%87%E6%A0%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9E%81%E5%A4%A7%E5%9E%8B%E6%8C%87%E6%A0%87">将非极大型指标转换为极大型指标</a><ul>
<li><a href="#%E6%9E%81%E5%B0%8F%E5%9E%8B%E6%8C%87%E6%A0%87%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%9E%81%E5%A4%A7%E5%9E%8B%E6%8C%87%E6%A0%87">极小型指标转化为极大型指标</a></li>
<li><a href="#%E4%B8%AD%E9%97%B4%E5%9E%8B%E6%8C%87%E6%A0%87%E8%BD%AC%E6%8D%A2%E6%9E%81%E5%A4%A7%E5%9E%8B%E6%8C%87%E6%A0%87">中间型指标转换极大型指标</a></li>
<li><a href="#%E5%8C%BA%E9%97%B4%E5%9E%8B%E6%8C%87%E6%A0%87%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%9E%81%E5%A4%A7%E5%9E%8B%E6%8C%87%E6%A0%87">区间型指标转化为极大型指标</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%AD%A3%E5%90%91%E7%9F%A9%E9%98%B5%E6%A0%87%E5%87%86%E5%8C%96">正向矩阵标准化</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%BE%97%E5%88%86%E5%B9%B6%E5%BD%92%E4%B8%80%E5%8C%96">计算得分并归一化</a></li>
<li><a href="#topsis%E7%BB%93%E5%90%88ahp">TOPSIS结合AHP</a></li>
</ul>
</li>
<li><a href="#matlab%E4%BB%A3%E7%A0%81">Matlab代码</a><ul>
<li><a href="#m%E8%84%9A%E6%9C%AC">.m脚本</a></li>
<li><a href="#%E5%BB%BA%E7%AB%8B%E7%9A%84%E5%87%BD%E6%95%B0">建立的函数</a><ul>
<li><a href="#%E6%AD%A3%E5%90%91%E5%8C%96%E5%87%BD%E6%95%B0positivization">正向化函数Positivization</a></li>
<li><a href="#%E6%9E%81%E5%B0%8F%E5%9E%8B%E8%BD%AC%E6%9E%81%E5%A4%A7%E5%9E%8Bmin2max">极小型转极大型Min2Max</a></li>
<li><a href="#%E5%8C%BA%E5%9F%9F%E5%9E%8B%E8%BD%AC%E6%9E%81%E5%A4%A7%E5%9E%8Binter2max">区域型转极大型Inter2Max</a></li>
<li><a href="#%E4%B8%AD%E9%97%B4%E5%9E%8B%E8%BD%AC%E6%9E%81%E5%A4%A7%E5%9E%8Bmid2max">中间型转极大型Mid2Max</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%A2%98%E5%A4%96%E8%AF%9D">题外话</a></li>
</ul>
</li>
</ul>
<h1 id="TOPSIS"><a href="#TOPSIS" class="headerlink" title="TOPSIS"></a>TOPSIS</h1><h2 id="TOPSIS原理"><a href="#TOPSIS原理" class="headerlink" title="TOPSIS原理"></a>TOPSIS原理</h2><p>TOPSIS法(Technique for Order Preference by Similarity to Ideal Solution)  </p>
<p>可翻译为逼近理想解排序法，国内常简称为优劣解距离法。  </p>
<p>TOPSIS法是一种常用的综合评价方法，其能充分<strong>利用原始数据</strong>的信息,其结果能精确地反映<strong>各评价方案之间的差距</strong>。</p>
<h3 id="层次分析法的局限"><a href="#层次分析法的局限" class="headerlink" title="层次分析法的局限"></a>层次分析法的局限</h3><p>(1)评价的决策层不能太多，太多的话n会很大，判断矩阵和一致矩阵差异可能会很大。</p>
<p><img src="https://dkyz.gitee.io//img/TOPSIS/image-20200702232535951.png" alt="image-20200702232535951"></p>
<p>平均随机一致性指标RI的表格中n最多是15。</p>
<p>(2) 如果决策层中指标的数据是已知的，层次分析法不能利用这些数据来使得评价更加准确</p>
<h3 id="问题引出TOPSIS分析法"><a href="#问题引出TOPSIS分析法" class="headerlink" title="问题引出TOPSIS分析法"></a>问题引出TOPSIS分析法</h3><p>小明同宿舍共有四名同学，他们第一学期的高数成绩如下表所示:</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702232826767.png" alt="image-20200702232826767"></p>
<p><strong>请你为这四名同学进行评分，该评分能合理的描述其高数成绩的高低。</strong></p>
<p>一个很简单想法：根据名次来决定评分：</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702232958260.png" alt="image-20200702232958260"></p>
<p>只要保证排名不变，那么评分就不会改变</p>
<p><strong>但是评分不能充分反映原始数据的全部信息</strong>：（如果小张下次又考第三名但成绩下降到了20分，评分还是原来的0.2分）</p>
<p>一个比较好的想法：<img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200703103951591.png" alt="image-20200703103951591"></p>
<p>新的评分<br><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200703104026705.png" alt="image-20200703104026705"></p>
<p><strong>为什么不用（max&#x3D;100,min&#x3D;0）呢？</strong></p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702233438908.png" alt="image-20200702233438908"></p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200703104939387.png" alt="image-20200703104939387"></p>
<p>（1）以指标中数据的最大值作为max最小值作为min唯一的缺点：成绩最高的评分为1，最低的评分为0。但是比较的对象一般要远大于两个。（例如比较一个班级的成绩）这样就对整体的影响很小。  </p>
<p>（2）有很多指标不存在理论上的最大值和最小值，例如衡量经济增长水平的指标：GDP增速</p>
<h4 id="问题拓展"><a href="#问题拓展" class="headerlink" title="问题拓展"></a>问题拓展</h4><p>新增加了一个指标，现在要综合评价四位同学，并为他们进行评分。<br><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200703110240773.png" alt="image-20200703110240773"></p>
<p>成绩是越高(大)越好，这样的指标称为极大型指标(效益型指标).<br>与他人争吵的次数越少(越小)越好，这样的指标称为极小型指标(成本型指标)<br><strong>为了便于评价，我们要统一指标类型</strong></p>
<p>将所有的指标转化为极大型称为指标正向化</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200703110501614.png" alt="image-20200703110501614"></p>
<p>极小型指标转换为极大型指标的公式：max - x<br>还有一个问题：不同的指标（成绩，争吵次数…的量纲不同。比如成绩正常的值是几十分，吵架正常的次数不能是几十次吧）<br><strong>为了消去不同指标量纲的影响， 需要对已经正向化的数据（矩阵）进行标准化处理。</strong><br>对其标准化的矩阵记为Z，Z中的每一一个元素: </p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200703111343414.png" alt="image-20200703111343414"></p>
<p>最后<strong>计算得分</strong></p>
<p>只有一个指标的时候:<br>构造计算评分的公式:<img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200703111623439.png" alt="image-20200703111623439">  </p>
<p>变形：<img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200703111659459.png" alt="image-20200703111659459"><br><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200703111716378.png" alt="image-20200703111716378"></p>
<p>这就是为什么TOPSIS被称为优劣解距离法。</p>
<h2 id="TOPSIS步骤"><a href="#TOPSIS步骤" class="headerlink" title="TOPSIS步骤"></a>TOPSIS步骤</h2><h3 id="将原始数据矩阵正向化"><a href="#将原始数据矩阵正向化" class="headerlink" title="将原始数据矩阵正向化"></a>将原始数据矩阵正向化</h3><h4 id="将非极大型指标转换为极大型指标"><a href="#将非极大型指标转换为极大型指标" class="headerlink" title="将非极大型指标转换为极大型指标"></a>将非极大型指标转换为极大型指标</h4><table>
<thead>
<tr>
<th>指标名称</th>
<th>指标特点</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>极大型（效益型）指标</td>
<td>越大（多）越好</td>
<td>成绩、GDP增速、企业利润</td>
</tr>
<tr>
<td>极小型（成本型）指标</td>
<td>越小（少）越好</td>
<td>费用、坏品率、污染程度</td>
</tr>
<tr>
<td>中间型指标</td>
<td>越接近某个值越好</td>
<td>水质量评估时的PH值</td>
</tr>
<tr>
<td>区间型指标</td>
<td>落在某个区间最好</td>
<td>体温、水中植物性营养物量</td>
</tr>
</tbody></table>
<h5 id="极小型指标转化为极大型指标"><a href="#极小型指标转化为极大型指标" class="headerlink" title="极小型指标转化为极大型指标"></a>极小型指标转化为极大型指标</h5><p>极小型指标转换为极大型指标的公式:max-x</p>
<p>例：</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702224708145.png" alt="image-20200702224708145"></p>
<h5 id="中间型指标转换极大型指标"><a href="#中间型指标转换极大型指标" class="headerlink" title="中间型指标转换极大型指标"></a>中间型指标转换极大型指标</h5><p>{xi }是一组中间型指标序列，且最佳的数值为xbest， 那么正向化的公式如下:</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702230239460.png" alt="image-20200702230239460"></p>
<p>例：令 Xbest&#x3D;7</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702230451069.png" alt="image-20200702230451069"></p>
<h5 id="区间型指标转化为极大型指标"><a href="#区间型指标转化为极大型指标" class="headerlink" title="区间型指标转化为极大型指标"></a>区间型指标转化为极大型指标</h5><p>区间型指标:指标值落在某个区间内最好，例如人的体温在36°~37°这个区间比较好。  </p>
<p>{xi}是一-组区间型指标序列，且最佳的区间为[a,b]， 那么正向化的公式如下:</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702230735625.png" alt="image-20200702230735625"><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702230743975.png" alt="image-20200702230743975"></p>
<p>例：</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702230912785.png" alt="image-20200702230912785"></p>
<h3 id="正向矩阵标准化"><a href="#正向矩阵标准化" class="headerlink" title="正向矩阵标准化"></a>正向矩阵标准化</h3><p><strong>标准化的目的是消除不同指标量纲的影响。</strong>  </p>
<p>假设有n个要评价的对象，m个评价指标(已经正向化了)构成的正向化矩阵如下:</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702231027386.png" alt="image-20200702231027386"></p>
<p>那么，对其标准化的矩阵记为Z，Z中的每一个元素:</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702231110724.png" alt="image-20200702231110724"></p>
<h3 id="计算得分并归一化"><a href="#计算得分并归一化" class="headerlink" title="计算得分并归一化"></a>计算得分并归一化</h3><p>假设有n个要评价的对象，m个评价指标的标准化矩阵:</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702231209329.png" alt="image-20200702231209329"></p>
<p>定义最大值：   <img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702231540971.png" alt="image-20200702231540971"><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702231354627.png" alt="image-20200702231354627"></p>
<p>定义最小值：</p>
<p><img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702231510412.png" alt="image-20200702231510412"></p>
<p>定义第i(i&#x3D;1,2, .n)个评价对象与最大值的距离：<img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702231722589.png" alt="image-20200702231722589"></p>
<p>定义第i(i&#x3D;1,2, .n)个评价对象与最小值的距离：<img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702231805418.png" alt="image-20200702231805418"></p>
<p>那么，我们可以计算得出第i(i&#x3D; 1,2, .. ,n)个评价对象未归一化的得分: <img src="http://dkyz.gitee.io/ccnu_zdl/img/TOPSIS/image-20200702232003517.png" alt="（z与最小值的距离/z与最大值的距离+ z与最小值的距离）">（z与最小值的距离&#x2F;z与最大值的距离+ z与最小值的距离）  </p>
<p>很明显0≤S;≤1，且S;越大D越小，即越接近最大值。</p>
<h3 id="TOPSIS结合AHP"><a href="#TOPSIS结合AHP" class="headerlink" title="TOPSIS结合AHP"></a>TOPSIS结合AHP</h3><p><strong>可以与层次分析法相结合，为每个比较的指标赋予权重</strong></p>
<h2 id="Matlab代码"><a href="#Matlab代码" class="headerlink" title="Matlab代码"></a>Matlab代码</h2><h3 id="m脚本"><a href="#m脚本" class="headerlink" title=".m脚本"></a>.m脚本</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  第一步：把数据复制到工作区，并将这个矩阵命名为X</span></span><br><span class="line"><span class="comment">% （1）在工作区右键，点击新建（Ctrl+N)，输入变量名称为X</span></span><br><span class="line"><span class="comment">% （2）在Excel中复制数据，再回到Excel中右键，点击粘贴Excel数据（Ctrl+Shift+V）</span></span><br><span class="line"><span class="comment">% （3）关掉这个窗口，点击X变量，右键另存为，保存为mat文件（下次就不用复制粘贴了，只需使用load命令即可加载数据）</span></span><br><span class="line"><span class="comment">% （4）注意，代码和数据要放在同一个目录下哦，且Matlab的当前文件夹也要是这个目录。</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">%%  第二步：判断是否需要正向化</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);    <span class="comment">%（n为评价对象数量，m为指标数量）</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) </span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： &#x27;</span>); </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>)</span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>); </span><br><span class="line">    <span class="comment">%这三行代码是为了知道哪些列需要正向化，其对应正向化的方法又是什么（极小型转极大型还是区域型转极大型还是...）%</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   </span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X =  &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：对正向化后的矩阵进行标准化</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(sum(X.*X) .^ <span class="number">0.5</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;标准化矩阵 Z = &#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算与最大值的距离和最小值的距离，并算出得分</span></span><br><span class="line">D_P = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">max</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D+ 与最大值的距离向量</span></span><br><span class="line">D_N = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">min</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D- 与最小值的距离向量</span></span><br><span class="line">S = D_N ./ (D_P+D_N);    <span class="comment">% 未归一化的得分</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最后的得分为：&#x27;</span>)</span><br><span class="line">stand_S = S / sum(S)</span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">&#x27;descend&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="建立的函数"><a href="#建立的函数" class="headerlink" title="建立的函数"></a>建立的函数</h3><h4 id="正向化函数Positivization"><a href="#正向化函数Positivization" class="headerlink" title="正向化函数Positivization"></a>正向化函数Positivization</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% function [输出变量] = 函数名称(输入变量）  </span></span><br><span class="line"><span class="comment">% 函数的中间部分都是函数体</span></span><br><span class="line"><span class="comment">% 函数的最后要用end结尾</span></span><br><span class="line"><span class="comment">% 输出变量和输入变量可以有多个，用逗号隔开</span></span><br><span class="line"><span class="comment">% function [a,b,c]=test(d,e,f)</span></span><br><span class="line"><span class="comment">%     a=d+e;</span></span><br><span class="line"><span class="comment">%     b=e+f;</span></span><br><span class="line"><span class="comment">%     c=f+d;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% 自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Positivization</span><span class="params">(x,type,i)</span></span></span><br><span class="line"><span class="comment">% 输入变量有三个：x,type,i</span></span><br><span class="line"><span class="comment">% x：需要正向化处理的指标对应的原始列向量</span></span><br><span class="line"><span class="comment">% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line"><span class="comment">% i: 正在处理的是原始矩阵中的哪一列</span></span><br><span class="line"><span class="comment">% 输出变量posit_x表示：正向化后的列向量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>  <span class="comment">%极小型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是极小型，正在正向化&#x27;</span>] )</span><br><span class="line">        posit_x = Min2Max(x);  <span class="comment">%调用Min2Max函数来正向化</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列极小型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">2</span>  <span class="comment">%中间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是中间型&#x27;</span>] )</span><br><span class="line">        best = input(<span class="string">&#x27;请输入最佳的那一个值： &#x27;</span>);</span><br><span class="line">        posit_x = Mid2Max(x,best);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列中间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">3</span>  <span class="comment">%区间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是区间型&#x27;</span>] )</span><br><span class="line">        a = input(<span class="string">&#x27;请输入区间的下界： &#x27;</span>);</span><br><span class="line">        b = input(<span class="string">&#x27;请输入区间的上界： &#x27;</span>); </span><br><span class="line">        posit_x = Inter2Max(x,a,b);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列区间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="极小型转极大型Min2Max"><a href="#极小型转极大型Min2Max" class="headerlink" title="极小型转极大型Min2Max"></a>极小型转极大型Min2Max</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Min2Max</span><span class="params">(x)</span></span></span><br><span class="line">    posit_x = <span class="built_in">max</span>(x) - x;</span><br><span class="line">     <span class="comment">%posit_x = 1 ./ x;    %如果x全部都大于0，也可以这样正向化</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="区域型转极大型Inter2Max"><a href="#区域型转极大型Inter2Max" class="headerlink" title="区域型转极大型Inter2Max"></a>区域型转极大型Inter2Max</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Inter2Max</span><span class="params">(x,a,b)</span></span></span><br><span class="line">    r_x = <span class="built_in">size</span>(x,<span class="number">1</span>);  <span class="comment">% row of x </span></span><br><span class="line">    M = <span class="built_in">max</span>([a-<span class="built_in">min</span>(x),<span class="built_in">max</span>(x)-b]);</span><br><span class="line">    posit_x = <span class="built_in">zeros</span>(r_x,<span class="number">1</span>);   <span class="comment">%zeros函数用法: zeros(3)  zeros(3,1)  ones(3)</span></span><br><span class="line">    <span class="comment">% 初始化posit_x全为0  初始化的目的是节省处理时间</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: r_x</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; a</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(a-x(<span class="built_in">i</span>))/M;</span><br><span class="line">        <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; b</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(x(<span class="built_in">i</span>)-b)/M;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="中间型转极大型Mid2Max"><a href="#中间型转极大型Mid2Max" class="headerlink" title="中间型转极大型Mid2Max"></a>中间型转极大型Mid2Max</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Mid2Max</span><span class="params">(x,best)</span></span></span><br><span class="line">    M = <span class="built_in">max</span>(<span class="built_in">abs</span>(x-best));</span><br><span class="line">    posit_x = <span class="number">1</span> - <span class="built_in">abs</span>(x-best) / M;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>学习优秀论文之前真的需要把论文里用到的模型大概了解了解   QAQ   </p>
<p>上次作业欣赏国赛优秀论文《葡萄酒的评价模型》，摘要里面用到的“极大型指标” “中间型指标” “..指标转化”……..一个都不知道，摘要都看不懂。在进行数据处理时就更懵逼了  QAQ<br>但在学完TOPSIS（优劣解距离法）后，再去看那篇论文.                 哇！金色传说！！！！！  </p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/dkyz/ccnu_zdl/raw/master/sources/TOPSIS/TOPSIS_putaojiupingjia.pdf">12年A题优秀论文葡萄酒的评价</a></p>
</article></div></main><div class="nav-wrap"><div class="nav"><button class="site-nav"><div class="navicon"></div></button><ul class="nav_items"><li class="nav_item"><a class="nav-page" href="/#Publications"> Publications</a></li><li class="nav_item"><a class="nav-page" href="/"> About</a></li><li class="nav_item"><a class="nav-page" target="_blank" rel="noopener" href="https://phower.me"> Blog</a></li></ul></div><div class="cd-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></div></div><footer id="page_footer"><div class="footer_wrap"><div class="copyright">&copy;2020 - 2023 by Delin Zhang</div><div class="theme-info">Powered by <a target="_blank" href="https://hexo.io" rel="nofollow noopener">Hexo</a> & <a target="_blank" href="https://github.com/PhosphorW/hexo-theme-academia" rel="nofollow noopener">Academia Theme</a></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-pjax@latest/jquery.pjax.min.js"></script><script src="/js/main.js"></script></body></html>